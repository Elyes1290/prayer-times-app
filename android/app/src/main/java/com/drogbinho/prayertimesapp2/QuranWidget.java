package com.drogbinho.prayertimesapp2;

import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.util.Log;
import android.widget.RemoteViews;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import static com.drogbinho.prayertimesapp2.ConditionalLogger.*;
import android.app.ActivityManager;

public class QuranWidget extends AppWidgetProvider {

    private static final String TAG = "QuranWidget";
    
    // Actions pour les boutons du widget
    private static final String ACTION_PLAY_PAUSE = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_PLAY_PAUSE";
    private static final String ACTION_PREVIOUS = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_PREVIOUS";
    private static final String ACTION_NEXT = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_NEXT";
    private static final String ACTION_OPEN_APP = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_OPEN_APP";
    private static final String ACTION_SEEK = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_SEEK";
    private static final String ACTION_REFRESH = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_REFRESH";
    
    // NOUVEAU : Actions pour les options de lecture
    private static final String ACTION_TOGGLE_AUTO_ADVANCE = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_TOGGLE_AUTO_ADVANCE";
    private static final String ACTION_TOGGLE_LOOP = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_TOGGLE_LOOP";
    

    
    // NOUVEAU : Action pour le diagnostic
    private static final String ACTION_DIAGNOSTIC = "com.drogbinho.prayertimesapp2.QURAN_WIDGET_DIAGNOSTIC";
    
    // Actions du service audio - maintenant d√©finies dans QuranAudioService

    // √âtats du widget
    private static boolean isPlaying = false;
    private static String currentSurah = "";
    private static String currentReciter = "";
    private static int currentPosition = 0;
    private static int totalDuration = 0;
    private static String currentAudioPath = "";
    private static boolean isPremiumUser = false;
    
    // üéØ NOUVEAU : √âtats des options de lecture
    private static boolean autoAdvanceEnabled = true;
    private static boolean loopEnabled = false;
    
    private static Context context;

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        widgetDebugLog(TAG, "üîÑ Widget Coran onUpdate appel√© pour " + appWidgetIds.length + " widgets");

        for (int appWidgetId : appWidgetIds) {
            updateQuranWidget(context, appWidgetManager, appWidgetId);
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        super.onReceive(context, intent);

        String action = intent.getAction();
        Log.d(TAG, "üîÑ Widget Coran onReceive action: " + action);
        widgetDebugLog(TAG, "üîÑ Widget Coran onReceive action: " + action);

        switch (action) {
            case ACTION_PLAY_PAUSE:
                Log.d(TAG, "üéµ Widget traite ACTION_PLAY_PAUSE");
                handlePlayPause(context);
                break;
            case ACTION_PREVIOUS:
                Log.d(TAG, "‚èÆÔ∏è Widget traite ACTION_PREVIOUS");
                handlePrevious(context);
                break;
            case ACTION_NEXT:
                Log.d(TAG, "‚è≠Ô∏è Widget traite ACTION_NEXT");
                handleNext(context);
                break;
            case ACTION_SEEK:
                int seekPosition = intent.getIntExtra("position", 0);
                Log.d(TAG, "üéØ Widget traite ACTION_SEEK: " + seekPosition);
                handleSeek(context, seekPosition);
                break;
            case ACTION_OPEN_APP:
                Log.d(TAG, "üì± Widget traite ACTION_OPEN_APP");
                openQuranScreen(context);
                break;
            case ACTION_REFRESH:
                Log.d(TAG, "üîÑ Widget traite ACTION_REFRESH");
                refreshWidget(context);
                break;
            case QuranAudioService.ACTION_AUDIO_STATE_CHANGED:
                Log.d(TAG, "üéµ Widget traite ACTION_AUDIO_STATE_CHANGED");
                // Mise √† jour depuis le service audio
                handleAudioStateChanged(intent);
                break;
            case QuranAudioService.ACTION_AUDIO_PROGRESS:
                Log.d(TAG, "üìä Widget traite ACTION_AUDIO_PROGRESS");
                // Mise √† jour de la progression
                handleAudioProgress(intent);
                break;
            case ACTION_TOGGLE_AUTO_ADVANCE:
                handleToggleAutoAdvance(context);
                break;
            case ACTION_TOGGLE_LOOP:
                handleToggleLoop(context);
                break;


            case ACTION_DIAGNOSTIC:
                Log.d(TAG, "üîç Widget traite ACTION_DIAGNOSTIC");
                runDiagnostic(context);
                break;
            default:
                Log.d(TAG, "Action inconnue re√ßue: " + action);
                break;
        }

        // Mettre √† jour tous les widgets
        updateAllWidgets(context);
    }

    @Override
    public void onEnabled(Context context) {
        super.onEnabled(context);
        QuranWidget.context = context;
        widgetDebugLog(TAG, "‚úÖ Widget Coran activ√©");
        
        // V√©rifier le statut premium
        checkPremiumStatus(context);
        
        // D√©marrer le service audio SEULEMENT si l'utilisateur est premium
        if (isPremiumUser) {
            try {
                Intent serviceIntent = new Intent(context, QuranAudioService.class);
                context.startService(serviceIntent);
                widgetDebugLog(TAG, "üéµ Service audio d√©marr√© depuis onEnabled (utilisateur premium)");
            } catch (Exception e) {
                Log.e(TAG, "‚ùå Erreur d√©marrage service depuis onEnabled: " + e.getMessage());
            }
        } else {
            widgetDebugLog(TAG, "‚ö†Ô∏è Service audio non d√©marr√© (utilisateur non premium)");
        }
    }

    @Override
    public void onDisabled(Context context) {
        widgetDebugLog(TAG, "‚ùå Widget Coran d√©sactiv√©");
        
        // Arr√™ter la lecture si le widget est supprim√©
        stopAudioPlayback();
    }

    static void updateQuranWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) {
        widgetDebugLog(TAG, "üîÑ Mise √† jour du widget Coran " + appWidgetId);

        try {
            // V√©rifier le statut premium √† chaque mise √† jour
            checkPremiumStatus(context);
            widgetDebugLog(TAG, "üëë Statut premium apr√®s v√©rification: " + isPremiumUser);
            
            // V√©rifier le statut premium
            if (!isPremiumUser) {
                widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium - affichage √©cran d'abonnement");
                showPremiumRequiredWidget(context, appWidgetManager, appWidgetId);
                return;
            }

            // Cr√©er les RemoteViews
            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.quran_widget);

            // Configurer les boutons avec PendingIntents
            setupWidgetButtons(context, views);

            // Mettre √† jour l'affichage
            updateWidgetDisplay(context, views);

            // Appliquer les RemoteViews
            appWidgetManager.updateAppWidget(appWidgetId, views);

            widgetDebugLog(TAG, "‚úÖ Widget Coran mis √† jour avec succ√®s");

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur mise √† jour widget Coran: " + e.getMessage());
        }
    }

    private static void setupWidgetButtons(Context context, RemoteViews views) {
        // Bouton Play/Pause
        Intent playPauseIntent = new Intent(context, QuranWidget.class);
        playPauseIntent.setAction(ACTION_PLAY_PAUSE);
        PendingIntent playPausePendingIntent = PendingIntent.getBroadcast(
            context, 0, playPauseIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_play_pause_button, playPausePendingIntent);

        // Bouton Pr√©c√©dent
        Intent previousIntent = new Intent(context, QuranWidget.class);
        previousIntent.setAction(ACTION_PREVIOUS);
        PendingIntent previousPendingIntent = PendingIntent.getBroadcast(
            context, 1, previousIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_previous_button, previousPendingIntent);

        // Bouton Suivant
        Intent nextIntent = new Intent(context, QuranWidget.class);
        nextIntent.setAction(ACTION_NEXT);
        PendingIntent nextPendingIntent = PendingIntent.getBroadcast(
            context, 2, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_next_button, nextPendingIntent);

        // Bouton Ouvrir App
        Intent openAppIntent = new Intent(context, QuranWidget.class);
        openAppIntent.setAction(ACTION_OPEN_APP);
        PendingIntent openAppPendingIntent = PendingIntent.getBroadcast(
            context, 3, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_open_app_button, openAppPendingIntent);
        
        // NOUVEAU : Bouton Auto-avancement
        Intent autoAdvanceIntent = new Intent(context, QuranWidget.class);
        autoAdvanceIntent.setAction(ACTION_TOGGLE_AUTO_ADVANCE);
        PendingIntent autoAdvancePendingIntent = PendingIntent.getBroadcast(
            context, 10, autoAdvanceIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_auto_advance_button, autoAdvancePendingIntent);
        
        // NOUVEAU : Bouton Boucle
        Intent loopIntent = new Intent(context, QuranWidget.class);
        loopIntent.setAction(ACTION_TOGGLE_LOOP);
        PendingIntent loopPendingIntent = PendingIntent.getBroadcast(
            context, 11, loopIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_loop_button, loopPendingIntent);


    }

    private static void updateWidgetDisplay(Context context, RemoteViews views) {
        // Mettre √† jour l'ic√¥ne play/pause
        int playPauseIcon = isPlaying ? R.drawable.ic_pause : R.drawable.ic_play;
        widgetDebugLog(TAG, "üéØ Mise √† jour ic√¥ne widget - isPlaying: " + isPlaying + " ‚Üí ic√¥ne: " + (isPlaying ? "PAUSE" : "PLAY"));
        views.setImageViewResource(R.id.quran_play_pause_button, playPauseIcon);

        // V√©rifier si l'audio est local
        boolean isAudioLocal = isCurrentAudioLocal(context);
        
        // Mettre √† jour le titre de la sourate avec traduction
        String surahDisplay;
        if (!isAudioLocal && !currentSurah.isEmpty()) {
            String streamingText = getTranslation(context, "streaming");
            surahDisplay = "üì° " + streamingText + " - " + currentSurah;
        } else {
            String noReadingText = getTranslation(context, "no_current_reading");
            surahDisplay = currentSurah.isEmpty() ? noReadingText : currentSurah;
        }
        views.setTextViewText(R.id.quran_surah_title, surahDisplay);

        // Mettre √† jour le nom du r√©citateur avec traduction
        String selectReciterText = getTranslation(context, "select_reciter");
        String reciterDisplay = currentReciter.isEmpty() ? selectReciterText : currentReciter;
        views.setTextViewText(R.id.quran_reciter_name, reciterDisplay);

        // Mettre √† jour la progression
        String progressText = formatTime(currentPosition) + " / " + formatTime(totalDuration);
        views.setTextViewText(R.id.quran_progress_text, progressText);

        // Mettre √† jour la barre de progression
        int progressPercent = totalDuration > 0 ? (currentPosition * 100) / totalDuration : 0;
        views.setProgressBar(R.id.quran_progress_bar, 100, progressPercent, false);

        // Badge premium
        views.setImageViewResource(R.id.quran_premium_badge, R.drawable.ic_premium_star);
        
        // SUPPRIM√â : Indicateur de r√©citateur (navigation entre r√©citateurs retir√©e)
        
        // MODIFI√â : Tous les boutons restent actifs, m√™me avec l'audio en streaming
        // R√©activer tous les boutons
        views.setInt(R.id.quran_previous_button, "setAlpha", 255);
        views.setInt(R.id.quran_next_button, "setAlpha", 255);
        
        // üéØ NOUVEAU : Mettre √† jour l'affichage des boutons auto-advance et loop
        updateAutoAdvanceButton(views);
        updateLoopButton(views);
    }
    
    /**
     * üéØ NOUVEAU : Mettre √† jour l'affichage du bouton auto-advance
     */
    private static void updateAutoAdvanceButton(RemoteViews views) {
        if (autoAdvanceEnabled) {
            // Bouton activ√© : couleur normale/opaque
            views.setInt(R.id.quran_auto_advance_button, "setAlpha", 255);
            views.setInt(R.id.quran_auto_advance_button, "setColorFilter", 0xFF4CAF50); // Vert
        } else {
            // Bouton d√©sactiv√© : couleur att√©nu√©e
            views.setInt(R.id.quran_auto_advance_button, "setAlpha", 128);
            views.setInt(R.id.quran_auto_advance_button, "setColorFilter", 0xFF757575); // Gris
        }
        widgetDebugLog(TAG, "üéØ Bouton auto-advance mis √† jour: " + (autoAdvanceEnabled ? "ACTIV√â" : "D√âSACTIV√â"));
    }
    
    /**
     * üéØ NOUVEAU : Mettre √† jour l'affichage du bouton loop
     */
    private static void updateLoopButton(RemoteViews views) {
        if (loopEnabled) {
            // Bouton activ√© : couleur normale/opaque
            views.setInt(R.id.quran_loop_button, "setAlpha", 255);
            views.setInt(R.id.quran_loop_button, "setColorFilter", 0xFF2196F3); // Bleu
        } else {
            // Bouton d√©sactiv√© : couleur att√©nu√©e
            views.setInt(R.id.quran_loop_button, "setAlpha", 128);
            views.setInt(R.id.quran_loop_button, "setColorFilter", 0xFF757575); // Gris
        }
        widgetDebugLog(TAG, "üéØ Bouton loop mis √† jour: " + (loopEnabled ? "ACTIV√â" : "D√âSACTIV√â"));
    }

    private static void showPremiumRequiredWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) {
        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.quran_widget_premium_required);
        
        // üåç NOUVEAU : Appliquer les traductions aux textes du widget premium
        try {
            // IDs des TextViews (je vais les ajouter au XML)
            views.setTextViewText(R.id.quran_premium_title, getTranslation(context, "widget_quran_premium_title"));
            views.setTextViewText(R.id.quran_premium_description, getTranslation(context, "widget_premium_description"));
            views.setTextViewText(R.id.quran_feature_1, getTranslation(context, "widget_feature_direct_play"));
            views.setTextViewText(R.id.quran_feature_2, getTranslation(context, "widget_feature_navigation"));
            views.setTextViewText(R.id.quran_feature_3, getTranslation(context, "widget_feature_audio_controls"));
            views.setTextViewText(R.id.quran_feature_4, getTranslation(context, "widget_feature_offline"));
            views.setTextViewText(R.id.quran_premium_required_button, getTranslation(context, "subscribe_premium"));
            
            widgetDebugLog(TAG, "üåç Traductions appliqu√©es au widget premium");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur application traductions widget premium: " + e.getMessage());
        }
        
        // Bouton pour ouvrir l'app et s'abonner
        Intent openAppIntent = new Intent(context, QuranWidget.class);
        openAppIntent.setAction(ACTION_OPEN_APP);
        PendingIntent openAppPendingIntent = PendingIntent.getBroadcast(
            context, 30, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
        );
        views.setOnClickPendingIntent(R.id.quran_premium_required_button, openAppPendingIntent);

        appWidgetManager.updateAppWidget(appWidgetId, views);
    }

    private static void handlePlayPause(Context context) {
        widgetDebugLog(TAG, "üéµ Action Play/Pause");
        widgetDebugLog(TAG, "üéµ √âtat actuel - isPremiumUser: " + isPremiumUser + ", currentAudioPath: '" + currentAudioPath + "'");
        
        if (!isPremiumUser) {
            widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium");
            return;
        }
        
        // V√©rifier si l'audio actuel est local
        boolean isAudioLocal = isCurrentAudioLocal(context);
        
        // Si aucun audio charg√© et pas d'audio local, ouvrir l'app
        if (currentAudioPath.isEmpty() && !isAudioLocal) {
            widgetDebugLog(TAG, "‚ö†Ô∏è Aucun audio charg√©, ouverture de l'app Coran");
            openQuranScreen(context);
            return;
        }

        widgetDebugLog(TAG, "üéµ Audio disponible: " + currentAudioPath + " (local: " + isAudioLocal + ")");

        // Le service sera d√©marr√© automatiquement par l'intent avec l'action

        // Envoyer l'action au service audio via startService
        Intent serviceIntent = new Intent(context, QuranAudioService.class);
        serviceIntent.setAction(QuranAudioService.ACTION_PLAY_PAUSE);
        widgetDebugLog(TAG, "üéµ Intent cr√©√© avec action: " + serviceIntent.getAction());
        widgetDebugLog(TAG, "üéµ Intent package: " + serviceIntent.getPackage());
        
        try {
            context.startService(serviceIntent);
            widgetDebugLog(TAG, "üéµ Action Play/Pause envoy√©e au service via startService");
            Log.d(TAG, "üéØ CENTRALIS√â: √âtat sera mis √† jour par le service via broadcast");
            
        } catch (Exception e) {
            widgetDebugLog(TAG, "‚ùå Erreur envoi startService: " + e.getMessage());
        }
    }

    private static void handlePrevious(Context context) {
        Log.d(TAG, "üéØ handlePrevious() - Navigation directe vers sourate pr√©c√©dente");
        widgetDebugLog(TAG, "üéØ Navigation pr√©c√©dente");
        
        if (!isPremiumUser) {
            Log.d(TAG, "‚ö†Ô∏è handlePrevious() - Utilisateur non premium");
            widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium");
            return;
        }
        
        // üéØ NOUVEAU : D√©cr√©menter la sourate dans le widget et charger le nouvel audio
        try {
            // Extraire le num√©ro actuel de la sourate depuis currentSurah
            if (currentSurah != null && currentSurah.contains("(") && currentSurah.contains(")")) {
                String surahNumberStr = currentSurah.substring(currentSurah.indexOf("(") + 1, currentSurah.indexOf(")"));
                int currentSurahNumber = Integer.parseInt(surahNumberStr);
                
                if (currentSurahNumber > 1) {
                    int previousSurahNumber = currentSurahNumber - 1;
                    String formattedNumber = String.format("%03d", previousSurahNumber);
                    
                    // Construire le nouveau nom de sourate (garder le m√™me r√©citateur)
                    String newSurahName = "Sourate " + formattedNumber + " - " + currentReciter;
                    currentSurah = newSurahName;
                    
                    Log.d(TAG, "üéØ Widget: Sourate mise √† jour vers " + formattedNumber);
                    widgetDebugLog(TAG, "üéØ Sourate widget: " + formattedNumber);
                    
                    // üéµ NOUVEAU : Charger le nouvel audio dans le service
                    Intent serviceIntent = new Intent(context, QuranAudioService.class);
                    serviceIntent.setAction(QuranAudioService.ACTION_LOAD_SURAH_BY_NUMBER);
                    serviceIntent.putExtra("surahNumber", previousSurahNumber);
                    serviceIntent.putExtra("autoPlay", true);
                    context.startService(serviceIntent);
                    
                    Log.d(TAG, "üéµ Widget: Demande de chargement sourate " + previousSurahNumber + " au service");
                    widgetDebugLog(TAG, "üéµ Chargement sourate: " + formattedNumber);
                } else {
                    Log.d(TAG, "üéØ Widget: D√©j√† √† la premi√®re sourate (001)");
                    widgetDebugLog(TAG, "üéØ D√©j√† √† la sourate 001");
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur mise √† jour sourate widget: " + e.getMessage());
        }
        
        // üéØ AM√âLIOR√â : Navigation avec sauvegarde √©tat pour synchronisation
        try {
            // Extraire le num√©ro de sourate actuel depuis currentSurah
            int extractedSurahNumber = 1; // valeur par d√©faut
            if (currentSurah != null && currentSurah.contains("(") && currentSurah.contains(")")) {
                try {
                    String surahNumberStr = currentSurah.substring(currentSurah.indexOf("(") + 1, currentSurah.indexOf(")"));
                    extractedSurahNumber = Integer.parseInt(surahNumberStr);
                } catch (Exception parseError) {
                    Log.w(TAG, "Erreur extraction num√©ro sourate: " + parseError.getMessage());
                }
            }
            
            // Sauvegarder l'√©tat de navigation dans SharedPreferences
            SharedPreferences prefs = context.getSharedPreferences("quran_widget_prefs", Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();
            editor.putInt("current_surah_number", extractedSurahNumber - 1);
            editor.putString("current_surah_name", currentSurah);
            editor.putString("current_reciter", currentReciter);
            editor.putLong("last_navigation_timestamp", System.currentTimeMillis());
            editor.apply();
            
            // Envoyer √©v√©nement React Native
            Intent intent = new Intent("com.drogbinho.prayertimesapp2.REACT_NATIVE_EVENT");
            intent.setPackage(context.getPackageName());
            intent.putExtra("eventName", "WidgetNavigatePrevious");
            intent.putExtra("surahNumber", extractedSurahNumber - 1);
            intent.putExtra("surahName", currentSurah);
            intent.putExtra("reciter", currentReciter);
            context.sendBroadcast(intent);
            
            Log.d(TAG, "üéØ √âv√©nement WidgetNavigatePrevious envoy√© avec √©tat sauvegard√©");
            widgetDebugLog(TAG, "üéØ Navigation pr√©c√©dente avec synchronisation");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur envoi √©v√©nement navigation: " + e.getMessage());
            widgetDebugLog(TAG, "‚ùå Erreur navigation: " + e.getMessage());
        }
        
        // üéØ Mettre √† jour l'affichage du widget
        updateAllWidgets(context);
        
        Log.d(TAG, "üéØ handlePrevious() - FIN");
    }

    private static void handleNext(Context context) {
        Log.d(TAG, "üéØ handleNext() - Navigation directe vers sourate suivante");
        widgetDebugLog(TAG, "üéØ Navigation suivante");
        
        if (!isPremiumUser) {
            Log.d(TAG, "‚ö†Ô∏è handleNext() - Utilisateur non premium");
            widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium");
            return;
        }
        
        // üéØ NOUVEAU : Incr√©menter la sourate dans le widget et charger le nouvel audio
        try {
            // Extraire le num√©ro actuel de la sourate depuis currentSurah
            if (currentSurah != null && currentSurah.contains("(") && currentSurah.contains(")")) {
                String surahNumberStr = currentSurah.substring(currentSurah.indexOf("(") + 1, currentSurah.indexOf(")"));
                int currentSurahNumber = Integer.parseInt(surahNumberStr);
                
                if (currentSurahNumber < 114) {
                    int nextSurahNumber = currentSurahNumber + 1;
                    String formattedNumber = String.format("%03d", nextSurahNumber);
                    
                    // Construire le nouveau nom de sourate (garder le m√™me r√©citateur)
                    String newSurahName = "Sourate " + formattedNumber + " - " + currentReciter;
                    currentSurah = newSurahName;
                    
                    Log.d(TAG, "üéØ Widget: Sourate mise √† jour vers " + formattedNumber);
                    widgetDebugLog(TAG, "üéØ Sourate widget: " + formattedNumber);
                    
                    // üéµ NOUVEAU : Charger le nouvel audio dans le service
                    Intent serviceIntent = new Intent(context, QuranAudioService.class);
                    serviceIntent.setAction(QuranAudioService.ACTION_LOAD_SURAH_BY_NUMBER);
                    serviceIntent.putExtra("surahNumber", nextSurahNumber);
                    serviceIntent.putExtra("autoPlay", true);
                    context.startService(serviceIntent);
                    
                    Log.d(TAG, "üéµ Widget: Demande de chargement sourate " + nextSurahNumber + " au service");
                    widgetDebugLog(TAG, "üéµ Chargement sourate: " + formattedNumber);
                } else {
                    Log.d(TAG, "üéØ Widget: D√©j√† √† la derni√®re sourate (114)");
                    widgetDebugLog(TAG, "üéØ D√©j√† √† la sourate 114");
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur mise √† jour sourate widget: " + e.getMessage());
        }
        
        // üéØ AM√âLIOR√â : Navigation avec sauvegarde √©tat pour synchronisation
        try {
            // Extraire le num√©ro de sourate actuel depuis currentSurah
            int extractedSurahNumber = 1; // valeur par d√©faut
            if (currentSurah != null && currentSurah.contains("(") && currentSurah.contains(")")) {
                try {
                    String surahNumberStr = currentSurah.substring(currentSurah.indexOf("(") + 1, currentSurah.indexOf(")"));
                    extractedSurahNumber = Integer.parseInt(surahNumberStr);
                } catch (Exception parseError) {
                    Log.w(TAG, "Erreur extraction num√©ro sourate: " + parseError.getMessage());
                }
            }
            
            // Sauvegarder l'√©tat de navigation dans SharedPreferences
            SharedPreferences prefs = context.getSharedPreferences("quran_widget_prefs", Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = prefs.edit();
            editor.putInt("current_surah_number", extractedSurahNumber + 1);
            editor.putString("current_surah_name", currentSurah);
            editor.putString("current_reciter", currentReciter);
            editor.putLong("last_navigation_timestamp", System.currentTimeMillis());
            editor.apply();
            
            // Envoyer √©v√©nement React Native
            Intent intent = new Intent("com.drogbinho.prayertimesapp2.REACT_NATIVE_EVENT");
            intent.setPackage(context.getPackageName());
            intent.putExtra("eventName", "WidgetNavigateNext");
            intent.putExtra("surahNumber", extractedSurahNumber + 1);
            intent.putExtra("surahName", currentSurah);
            intent.putExtra("reciter", currentReciter);
            context.sendBroadcast(intent);
            
            Log.d(TAG, "üéØ √âv√©nement WidgetNavigateNext envoy√© avec √©tat sauvegard√©");
            widgetDebugLog(TAG, "üéØ Navigation suivante avec synchronisation");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur envoi √©v√©nement navigation: " + e.getMessage());
            widgetDebugLog(TAG, "‚ùå Erreur navigation: " + e.getMessage());
        }
        
        // üéØ Mettre √† jour l'affichage du widget
        updateAllWidgets(context);
        
        Log.d(TAG, "üéØ handleNext() - FIN");
    }

    private static void handleSeek(Context context, int position) {
        widgetDebugLog(TAG, "üéØ Action Seek vers position: " + position);
        
        if (!isPremiumUser) return;
        
        // Envoyer l'action au service audio via broadcast
        Intent serviceIntent = new Intent(QuranAudioService.ACTION_SEEK);
        serviceIntent.setPackage(context.getPackageName());
        serviceIntent.putExtra("position", position);
        
        try {
            context.sendBroadcast(serviceIntent);
            widgetDebugLog(TAG, "üéµ Action Seek envoy√©e au service via broadcast");
        } catch (Exception e) {
            widgetDebugLog(TAG, "‚ùå Erreur envoi broadcast: " + e.getMessage());
        }
    }

    private static void openQuranScreen(Context context) {
        try {
            Intent intent = new Intent(context, MainActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.putExtra("screen", "quran");
            context.startActivity(intent);
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur ouverture √©cran Coran: " + e.getMessage());
        }
    }

    private static void refreshWidget(Context context) {
        widgetDebugLog(TAG, "üîÑ Actualisation du widget");
        updateAllWidgets(context);
    }

    public static void updateAllWidgets(Context context) {
        try {
            AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
            ComponentName thisWidget = new ComponentName(context, QuranWidget.class);
            int[] appWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget);

            widgetDebugLog(TAG, "üì± Mise √† jour de " + appWidgetIds.length + " widgets avec context: " + (context != null ? "OUI" : "NON"));

            for (int appWidgetId : appWidgetIds) {
                updateQuranWidget(context, appWidgetManager, appWidgetId);
            }
            
            widgetDebugLog(TAG, "‚úÖ Tous les widgets mis √† jour");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur mise √† jour widgets: " + e.getMessage());
        }
    }
    
    // NOUVEAU : M√©thode pour forcer la mise √† jour imm√©diate d'un widget sp√©cifique
    public static void forceUpdateWidget(Context context, int appWidgetId) {
        try {
            AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
            widgetDebugLog(TAG, "üöÄ Mise √† jour forc√©e du widget " + appWidgetId);
            
            // Mettre √† jour le widget
            updateQuranWidget(context, appWidgetManager, appWidgetId);
            
            // Forcer la mise √† jour imm√©diate
            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetId, R.id.quran_play_pause_button);
            
            widgetDebugLog(TAG, "‚úÖ Widget " + appWidgetId + " mis √† jour de force");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur mise √† jour forc√©e widget: " + e.getMessage());
        }
    }

    private static void checkPremiumStatus(Context context) {
        try {
            // Le module natif met √† jour les SharedPreferences avec le bon statut
            SharedPreferences prefs = context.getSharedPreferences("premium_prefs", Context.MODE_PRIVATE);
            isPremiumUser = prefs.getBoolean("is_premium_user", false);
            widgetDebugLog(TAG, "üëë Statut premium: " + isPremiumUser);
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur v√©rification premium: " + e.getMessage());
            isPremiumUser = false;
        }
    }

    // üéØ SUPPRIM√â: Ces m√©thodes sont maintenant inutiles car tout passe par le service centralis√©

    private static void stopAudioPlayback() {
        // Logique d'arr√™t audio
        // √Ä impl√©menter avec MediaPlayer
        isPlaying = false;
        widgetDebugLog(TAG, "‚èπÔ∏è Lecture audio arr√™t√©e");
    }

    private static String formatTime(int milliseconds) {
        int seconds = (milliseconds / 1000) % 60;
        int minutes = (milliseconds / (1000 * 60)) % 60;
        int hours = (milliseconds / (1000 * 60 * 60));
        
        // üéØ NOUVEAU : Afficher les heures si la dur√©e d√©passe 1 heure
        if (hours > 0) {
            return String.format(Locale.getDefault(), "%d:%02d:%02d", hours, minutes, seconds);
        } else {
            return String.format(Locale.getDefault(), "%02d:%02d", minutes, seconds);
        }
    }

    /**
     * üåç R√©cup√®re la langue courante depuis les SharedPreferences
     */
    private static String getCurrentLanguage(Context context) {
        widgetDebugLog(TAG, "üåç DEBUG: D√©but r√©cup√©ration langue courante");

        try {
            SharedPreferences prefs = context.getSharedPreferences("prayer_times_settings", Context.MODE_PRIVATE);

            // Essayer plusieurs cl√©s possibles
            String[] possibleKeys = { "currentLanguage", "current_language", "language" };

            for (String key : possibleKeys) {
                String language = prefs.getString(key, null);
                if (language != null && !language.isEmpty()) {
                    widgetDebugLog(TAG, "‚úÖ Langue trouv√©e avec cl√© '" + key + "': " + language);
                    return language;
                }
                widgetDebugLog(TAG, "‚ùå Pas de langue pour cl√©: " + key);
            }

            // Debug: afficher toutes les SharedPreferences
            widgetDebugLog(TAG, "üîç TOUTES les SharedPreferences:");
            Map<String, ?> allPrefs = prefs.getAll();
            for (Map.Entry<String, ?> entry : allPrefs.entrySet()) {
                widgetDebugLog(TAG, "  - " + entry.getKey() + " = " + entry.getValue());
            }

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur r√©cup√©ration langue: " + e.getMessage());
        }

        widgetDebugLog(TAG, "‚ö†Ô∏è Aucune langue trouv√©e, utilisation fallback: en");
        return "en"; // English comme langue par d√©faut
    }

    /**
     * üåç R√©cup√®re une traduction depuis les fichiers locales_XX.json
     */
    public static String getTranslation(Context context, String key) {
        String language = getCurrentLanguage(context);
        widgetDebugLog(TAG, "üåç Tentative lecture locales_" + language + ".json pour cl√©: " + key);

        try {
            String fileName = "locales_" + language + ".json";

            InputStream inputStream = context.getAssets().open(fileName);
            InputStreamReader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);

            StringBuilder jsonBuilder = new StringBuilder();
            char[] buffer = new char[1024];
            int length;
            while ((length = reader.read(buffer)) != -1) {
                jsonBuilder.append(buffer, 0, length);
            }

            JSONObject translations = new JSONObject(jsonBuilder.toString());

            if (translations.has(key)) {
                String translation = translations.getString(key);
                widgetDebugLog(TAG, "‚úÖ Traduction trouv√©e: " + key + " = " + translation);
                return translation;
            } else {
                widgetDebugLog(TAG, "‚ö†Ô∏è Cl√© '" + key + "' non trouv√©e dans " + fileName);
                return key; // Fallback vers la cl√©
            }

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur lecture traduction " + language + " pour '" + key + "': " + e.getMessage());
            return key; // Fallback vers la cl√©
        }
    }

    /**
     * Extraire le num√©ro de sourate depuis le nom
     */
    private static int extractSurahNumberFromName(String surahName) {
        if (surahName == null || surahName.isEmpty()) {
            return 0;
        }
        
        // Chercher le pattern (XXX) dans le nom
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("\\((\\d{3})\\)");
        java.util.regex.Matcher matcher = pattern.matcher(surahName);
        
        if (matcher.find()) {
            try {
                return Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                Log.e(TAG, "‚ùå Erreur parsing num√©ro sourate: " + e.getMessage());
                return 0;
            }
        }
        
        return 0;
    }
    
    /**
     * Obtenir le nom de sourate depuis le num√©ro
     */
    private static String getSurahNameFromNumber(int surahNumber) {
        if (surahNumber < 1 || surahNumber > 114) {
            return null;
        }
        
        // Liste des 114 sourates du Coran
        String[] surahNames = {
            "Al-Fatiha", "Al-Baqarah", "Aal-E-Imran", "An-Nisa", "Al-Maidah", "Al-An'am", "Al-A'raf", "Al-Anfal", "At-Tawbah", "Yunus",
            "Hud", "Yusuf", "Ar-Ra'd", "Ibrahim", "Al-Hijr", "An-Nahl", "Al-Isra", "Al-Kahf", "Maryam", "Ta-Ha",
            "Al-Anbya", "Al-Hajj", "Al-Mu'minun", "An-Nur", "Al-Furqan", "Ash-Shu'ara", "An-Naml", "Al-Qasas", "Al-Ankabut", "Ar-Rum",
            "Luqman", "As-Sajdah", "Al-Ahzab", "Saba", "Fatir", "Ya-Sin", "As-Saffat", "Sad", "Az-Zumar", "Ghafir",
            "Fussilat", "Ash-Shura", "Az-Zukhruf", "Ad-Dukhan", "Al-Jathiyah", "Al-Ahqaf", "Muhammad", "Al-Fath", "Al-Hujurat", "Qaf",
            "Adh-Dhariyat", "At-Tur", "An-Najm", "Al-Qamar", "Ar-Rahman", "Al-Waqi'ah", "Al-Hadid", "Al-Mujadila", "Al-Hashr", "Al-Mumtahanah",
            "As-Saf", "Al-Jumu'ah", "Al-Munafiqun", "At-Taghabun", "At-Talaq", "At-Tahrim", "Al-Mulk", "Al-Qalam", "Al-Haqqah", "Al-Ma'arij",
            "Nuh", "Al-Jinn", "Al-Muzzammil", "Al-Muddathir", "Al-Qiyamah", "Al-Insan", "Al-Mursalat", "An-Naba", "An-Nazi'at", "Abasa",
            "At-Takwir", "Al-Infitar", "Al-Mutaffifin", "Al-Inshiqaq", "Al-Buruj", "At-Tariq", "Al-A'la", "Al-Ghashiyah", "Al-Fajr", "Al-Balad",
            "Ash-Shams", "Al-Layl", "Ad-Duha", "Ash-Sharh", "At-Tin", "Al-'Alaq", "Al-Qadr", "Al-Bayyinah", "Az-Zalzalah", "Al-'Adiyat",
            "Al-Qari'ah", "At-Takathur", "Al-'Asr", "Al-Humazah", "Al-Fil", "Quraish", "Al-Ma'un", "Al-Kawthar", "Al-Kafirun", "An-Nasr",
            "Al-Masad", "Al-Ikhlas", "Al-Falaq", "An-Nas"
        };
        
        return surahNames[surahNumber - 1] + " (" + String.format("%03d", surahNumber) + ")";
    }

    // M√©thodes publiques pour la communication avec l'app principale
    public static void updateCurrentAudio(Context context, String surah, String reciter, String audioPath) {
        currentSurah = surah;
        currentReciter = reciter;
        currentAudioPath = audioPath;
        widgetDebugLog(TAG, "üìª Audio mis √† jour: " + surah + " - " + reciter + " - " + audioPath);
        
        // Mettre √† jour le widget
        if (context != null) {
            updateAllWidgets(context);
        }
    }

    /**
     * üéØ NOUVEAU : Obtenir l'√©tat de lecture actuel du widget
     */
    public static boolean getWidgetPlayingState() {
        try {
            if (context != null) {
                SharedPreferences prefs = context.getSharedPreferences("quran_widget_state", Context.MODE_PRIVATE);
                boolean playing = prefs.getBoolean("isPlaying", false);
                Log.d(TAG, "üéØ √âtat lecture widget r√©cup√©r√©: " + playing);
                return playing;
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur r√©cup√©ration √©tat lecture widget: " + e.getMessage());
        }
        return false;
    }

    public static void updatePlaybackState(boolean playing, int position, int duration) {
        isPlaying = playing;
        currentPosition = position;
        totalDuration = duration;
        widgetDebugLog(TAG, "üéµ √âtat lecture mis √† jour: " + (playing ? "lecture" : "pause"));
        
        // üéØ NOUVEAU : Sauvegarder l'√©tat dans SharedPreferences pour synchronisation
        try {
            if (context != null) {
                SharedPreferences prefs = context.getSharedPreferences("quran_widget_state", Context.MODE_PRIVATE);
                SharedPreferences.Editor editor = prefs.edit();
                editor.putBoolean("isPlaying", playing);
                editor.putInt("currentPosition", position);
                editor.putInt("totalDuration", duration);
                editor.putLong("last_update_timestamp", System.currentTimeMillis());
                editor.apply();
                Log.d(TAG, "üéØ √âtat lecture sauvegard√© pour synchronisation: " + playing);
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur sauvegarde √©tat lecture: " + e.getMessage());
        }
        
        // NOUVEAU : Mettre √† jour imm√©diatement tous les widgets
        if (context != null) {
            widgetDebugLog(TAG, "üöÄ Mise √† jour imm√©diate des widgets apr√®s changement d'√©tat");
            updateAllWidgets(context);
        }
    }

    public static void setPremiumStatus(boolean premium) {
        isPremiumUser = premium;
        widgetDebugLog(TAG, "üëë Statut premium mis √† jour: " + premium);
        // Forcer la mise √† jour de tous les widgets
        if (context != null) {
            updateAllWidgets(context);
        }
    }
    
    /**
     * üéØ NOUVEAU : Mettre √† jour les √©tats des options de lecture
     */
    public static void updateReadingOptions(boolean autoAdvance, boolean loop) {
        autoAdvanceEnabled = autoAdvance;
        loopEnabled = loop;
        widgetDebugLog(TAG, "üéØ Options de lecture mises √† jour - Auto-advance: " + autoAdvance + ", Loop: " + loop);
        
        // Mettre √† jour imm√©diatement tous les widgets
        if (context != null) {
            widgetDebugLog(TAG, "üöÄ Mise √† jour imm√©diate des widgets apr√®s changement d'options");
            updateAllWidgets(context);
        }
    }
    
    /**
     * G√©rer les mises √† jour d'√©tat du service audio
     */
    private static void handleAudioStateChanged(Intent intent) {
        boolean wasPlaying = isPlaying;
        boolean newServicePlaying = intent.getBooleanExtra("isPlaying", false);
        
        // üéØ NOUVEAU : V√©rifier si l'√©tat du service diff√®re de notre √©tat local
        if (wasPlaying != newServicePlaying) {
            Log.d(TAG, "üéØ Correction √©tat widget: local=" + wasPlaying + " ‚Üí service=" + newServicePlaying);
        }
        
        isPlaying = newServicePlaying;
        currentSurah = intent.getStringExtra("surah");
        currentReciter = intent.getStringExtra("reciter");
        currentPosition = intent.getIntExtra("position", 0);
        totalDuration = intent.getIntExtra("duration", 0);
        currentAudioPath = intent.getStringExtra("audioPath");
        isPremiumUser = intent.getBooleanExtra("isPremium", false);
        
        // üéØ NOUVEAU : R√©cup√©rer les √©tats des options de lecture
        boolean newAutoAdvance = intent.getBooleanExtra("autoAdvanceEnabled", true);
        boolean newLoop = intent.getBooleanExtra("loopEnabled", false);
        
        // üéØ NOUVEAU : Ne mettre √† jour que si les √©tats ont chang√© (√©viter mise √† jour inutile)
        if (autoAdvanceEnabled != newAutoAdvance || loopEnabled != newLoop) {
            autoAdvanceEnabled = newAutoAdvance;
            loopEnabled = newLoop;
            widgetDebugLog(TAG, "üéØ Options mises √† jour - Auto-advance: " + autoAdvanceEnabled + ", Loop: " + loopEnabled);
        }
        
        // üéØ NOUVEAU : Sauvegarder l'√©tat corrig√©
        updatePlaybackState(isPlaying, currentPosition, totalDuration);
        
        widgetDebugLog(TAG, "üéµ √âtat audio mis √† jour: " + (isPlaying ? "Lecture" : "Pause") + 
                      " - " + currentSurah + " - " + currentReciter);
        widgetDebugLog(TAG, "üîÑ Changement d'√©tat: " + (wasPlaying ? "Lecture" : "Pause") + " ‚Üí " + (isPlaying ? "Lecture" : "Pause"));
        
        // NOUVEAU : Mettre √† jour le widget m√™me si context est null
        // Le service appellera directement updateAllWidgets avec son context
        widgetDebugLog(TAG, "üì± √âtat mis √† jour - isPlaying: " + isPlaying + ", ic√¥ne devrait changer");
        
        // NOUVEAU : Mettre √† jour imm√©diatement tous les widgets si on a un context
        if (context != null) {
            widgetDebugLog(TAG, "üöÄ Mise √† jour imm√©diate des widgets apr√®s changement d'√©tat");
            updateAllWidgets(context);
        } else {
            widgetDebugLog(TAG, "‚ö†Ô∏è Context null, mise √† jour diff√©r√©e");
        }
    }
    
    /**
     * G√©rer les mises √† jour de progression du service audio
     */
    private static void handleAudioProgress(Intent intent) {
        currentPosition = intent.getIntExtra("position", 0);
        totalDuration = intent.getIntExtra("duration", 0);
        
        // Mettre √† jour le widget
        if (context != null) {
            updateAllWidgets(context);
        }
    }

    private static void handleOpenApp(Context context) {
        widgetDebugLog(TAG, "üì± Ouverture de l'application");
        openQuranScreen(context);
    }
    
    /**
     * NOUVEAU : G√©rer le toggle auto-avancement
     */
    private static void handleToggleAutoAdvance(Context context) {
        widgetDebugLog(TAG, "üîÑ Toggle auto-avancement");
        
        if (!isPremiumUser) {
            widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium");
            return;
        }
        
        // üéØ NOUVEAU : Basculer imm√©diatement l'√©tat local pour mise √† jour visuelle rapide
        autoAdvanceEnabled = !autoAdvanceEnabled;
        widgetDebugLog(TAG, "üéØ Auto-advance bascul√© localement: " + autoAdvanceEnabled);
        
        // Mettre √† jour imm√©diatement l'affichage du widget
        updateAllWidgets(context);
        
        // Envoyer l'action au service audio
        Intent serviceIntent = new Intent(QuranAudioService.ACTION_TOGGLE_AUTO_ADVANCE);
        serviceIntent.setPackage(context.getPackageName());
        context.sendBroadcast(serviceIntent);
        
        widgetDebugLog(TAG, "üîÑ Action auto-avancement envoy√©e au service");
    }
    
    /**
     * NOUVEAU : G√©rer le toggle boucle
     */
    private static void handleToggleLoop(Context context) {
        widgetDebugLog(TAG, "üîÑ Toggle boucle");
        
        if (!isPremiumUser) {
            widgetDebugLog(TAG, "‚ö†Ô∏è Utilisateur non premium");
            return;
        }
        
        // üéØ NOUVEAU : Basculer imm√©diatement l'√©tat local pour mise √† jour visuelle rapide
        loopEnabled = !loopEnabled;
        widgetDebugLog(TAG, "üéØ Loop bascul√© localement: " + loopEnabled);
        
        // Mettre √† jour imm√©diatement l'affichage du widget
        updateAllWidgets(context);
        
        // Envoyer l'action au service audio
        Intent serviceIntent = new Intent(QuranAudioService.ACTION_TOGGLE_LOOP);
        serviceIntent.setPackage(context.getPackageName());
        context.sendBroadcast(serviceIntent);
        
        widgetDebugLog(TAG, "üîÑ Action boucle envoy√©e au service");
    }
    


    
    /**
     * NOUVEAU : V√©rifier s'il y a des r√©citateurs t√©l√©charg√©s
     */
    private static boolean hasDownloadedReciters(Context context) {
        try {
            String quranDir = context.getFilesDir().getAbsolutePath() + "/quran";
            java.io.File quranFolder = new java.io.File(quranDir);
            
            if (!quranFolder.exists() || !quranFolder.isDirectory()) {
                Log.d(TAG, "üìÅ Dossier Quran non trouv√©: " + quranDir);
                return false;
            }
            
            // Scanner tous les dossiers de r√©citateurs
            java.io.File[] reciterFolders = quranFolder.listFiles(java.io.File::isDirectory);
            if (reciterFolders != null) {
                for (java.io.File reciterFolder : reciterFolders) {
                    // V√©rifier qu'il y a au moins une sourate t√©l√©charg√©e
                    java.io.File[] mp3Files = reciterFolder.listFiles((dir, name) -> name.toLowerCase().endsWith(".mp3"));
                    if (mp3Files != null && mp3Files.length > 0) {
                        Log.d(TAG, "‚úÖ R√©citateur t√©l√©charg√© trouv√©: " + reciterFolder.getName());
                        return true;
                    }
                }
            }
            
            Log.d(TAG, "üìÅ Aucun r√©citateur t√©l√©charg√© trouv√©");
            return false;
            
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur v√©rification r√©citateurs t√©l√©charg√©s: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * NOUVEAU : V√©rifier si l'audio actuel est local (t√©l√©charg√©)
     */
    private static boolean isCurrentAudioLocal(Context context) {
        try {
            Log.d(TAG, "üîç V√©rification audio local - currentReciter: '" + currentReciter + "', currentSurah: '" + currentSurah + "'");
            
            // OPTIMISATION : V√©rifier d'abord si c'est du streaming pour √©viter les v√©rifications fichiers inutiles
            if (currentAudioPath != null && !currentAudioPath.isEmpty()) {
                if (currentAudioPath.startsWith("http://") || currentAudioPath.startsWith("https://")) {
                    // CORRECTION CRITIQUE : Si l'URL n'a pas de token, l'ajouter
                    if (!currentAudioPath.contains("&token=")) {
                        Log.w(TAG, "‚ö†Ô∏è URL sans token d√©tect√©e, correction automatique...");
                        currentAudioPath = addTokenToUrl(context, currentAudioPath);
                        Log.d(TAG, "‚úÖ URL corrig√©e: " + currentAudioPath);
                    }
                    Log.d(TAG, "üåê Audio streaming d√©tect√©: " + currentAudioPath);
                    return false; // C'est du streaming, pas local
                }
            }
            
            // V√©rifier si le r√©citateur actuel a des fichiers t√©l√©charg√©s
            if (currentReciter == null || currentReciter.isEmpty()) {
                Log.d(TAG, "üìÅ Aucun r√©citateur actuel");
                return false;
            }
            
            // Construire le chemin du dossier du r√©citateur
            String quranDir = context.getFilesDir().getAbsolutePath() + "/quran";
            String reciterDir = quranDir + "/" + currentReciter.replace(" ", "_");
            java.io.File reciterFolder = new java.io.File(reciterDir);
            
            Log.d(TAG, "üìÅ V√©rification dossier: " + reciterDir);
            
            if (!reciterFolder.exists() || !reciterFolder.isDirectory()) {
                Log.d(TAG, "üìÅ Dossier r√©citateur non trouv√©: " + reciterDir);
                return false;
            }
            
            // V√©rifier s'il y a des fichiers MP3
            java.io.File[] mp3Files = reciterFolder.listFiles((dir, name) -> name.toLowerCase().endsWith(".mp3"));
            if (mp3Files == null || mp3Files.length == 0) {
                Log.d(TAG, "üìÅ Aucun fichier MP3 trouv√© pour le r√©citateur: " + currentReciter);
                return false;
            }
            
            Log.d(TAG, "üìÅ Fichiers MP3 trouv√©s: " + mp3Files.length);
            
            // V√©rifier si la sourate actuelle est t√©l√©charg√©e
            int currentSurahNumber = extractSurahNumberFromName(currentSurah);
            Log.d(TAG, "üîç Num√©ro de sourate extrait: " + currentSurahNumber);
            
            if (currentSurahNumber > 0) {
                String formattedNumber = String.format("%03d", currentSurahNumber);
                String surahName = getSurahNameFromNumber(currentSurahNumber);
                if (surahName != null) {
                    String fileName = formattedNumber + "_" + surahName.replace("'", "").replace("-", "") + ".mp3";
                    java.io.File surahFile = new java.io.File(reciterDir, fileName);
                    Log.d(TAG, "üîç V√©rification fichier: " + fileName + " - existe: " + surahFile.exists());
                    if (surahFile.exists()) {
                        Log.d(TAG, "‚úÖ Audio local d√©tect√©: " + fileName);
                        return true;
                    } else {
                        Log.d(TAG, "üìÅ Fichier sourate non trouv√©: " + fileName);
                    }
                }
            }
            
            // Cette v√©rification streaming a √©t√© optimis√©e et d√©plac√©e au d√©but de la m√©thode
            
            Log.d(TAG, "üìÅ Audio non local d√©tect√©");
            return false;
            
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur v√©rification audio local: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * NOUVEAU : Ajouter le token d'authentification √† une URL
     */
    private static String addTokenToUrl(Context context, String originalUrl) {
        try {
            if (originalUrl == null || originalUrl.isEmpty()) {
                return originalUrl;
            }
            
            // R√©cup√©rer le token depuis les SharedPreferences
            android.content.SharedPreferences prefs = context.getSharedPreferences("premium_prefs", Context.MODE_PRIVATE);
            String userToken = prefs.getString("user_token", "");
            
            if (!userToken.isEmpty()) {
                Log.d(TAG, "üîó Token trouv√© dans le widget, ajout √† l'URL");
                return originalUrl + "&token=" + userToken;
            } else {
                Log.w(TAG, "‚ö†Ô∏è Aucun token trouv√© dans le widget");
                return originalUrl;
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur ajout token: " + e.getMessage());
            return originalUrl;
        }
    }

    /**
     * NOUVEAU : M√©thode de diagnostic pour tester l'√©tat complet du syst√®me
     */
    public static void runDiagnostic(Context context) {
        Log.d(TAG, "üîç DIAGNOSTIC COMPLET DU SYST√àME WIDGET QURAN");
        widgetDebugLog(TAG, "üîç D√©marrage diagnostic complet");
        
        // 1. V√©rifier le statut premium
        checkPremiumStatus(context);
        Log.d(TAG, "üîç 1. Statut premium: " + isPremiumUser);
        widgetDebugLog(TAG, "üîç Statut premium: " + isPremiumUser);
        
        // 2. V√©rifier l'√©tat actuel
        Log.d(TAG, "üîç 2. √âtat actuel:");
        Log.d(TAG, "üîç - currentSurah: '" + currentSurah + "'");
        Log.d(TAG, "üîç - currentReciter: '" + currentReciter + "'");
        Log.d(TAG, "üîç - currentAudioPath: '" + currentAudioPath + "'");
        Log.d(TAG, "üîç - isPlaying: " + isPlaying);
        
        // 3. V√©rifier si le service est en cours d'ex√©cution
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        boolean isServiceRunning = false;
        for (ActivityManager.RunningServiceInfo service : am.getRunningServices(Integer.MAX_VALUE)) {
            if (QuranAudioService.class.getName().equals(service.service.getClassName())) {
                isServiceRunning = true;
                break;
            }
        }
        Log.d(TAG, "üîç 3. Service en cours d'ex√©cution: " + isServiceRunning);
        widgetDebugLog(TAG, "üîç Service en cours: " + isServiceRunning);
        
        // 4. V√©rifier les sourates t√©l√©charg√©es
        try {
            String quranDir = context.getFilesDir().getAbsolutePath() + "/quran";
            java.io.File quranFolder = new java.io.File(quranDir);
            Log.d(TAG, "üîç 4. Dossier Quran: " + quranDir);
            Log.d(TAG, "üîç - Dossier existe: " + quranFolder.exists());
            
            if (quranFolder.exists()) {
                java.io.File[] reciterFolders = quranFolder.listFiles(java.io.File::isDirectory);
                Log.d(TAG, "üîç - Nombre de r√©citateurs: " + (reciterFolders != null ? reciterFolders.length : 0));
                
                if (reciterFolders != null) {
                    for (java.io.File reciterFolder : reciterFolders) {
                        Log.d(TAG, "üîç - R√©citateur: " + reciterFolder.getName());
                        java.io.File[] mp3Files = reciterFolder.listFiles((dir, name) -> name.toLowerCase().endsWith(".mp3"));
                        Log.d(TAG, "üîç - Fichiers MP3: " + (mp3Files != null ? mp3Files.length : 0));
                        
                        if (mp3Files != null && mp3Files.length > 0) {
                            for (java.io.File file : mp3Files) {
                                Log.d(TAG, "üîç - Fichier: " + file.getName());
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur diagnostic sourates: " + e.getMessage());
        }
        
        // 5. V√©rifier l'audio local actuel
        boolean isAudioLocal = isCurrentAudioLocal(context);
        Log.d(TAG, "üîç 5. Audio local actuel: " + isAudioLocal);
        widgetDebugLog(TAG, "üîç Audio local: " + isAudioLocal);
        
        // 6. Tester l'envoi d'une action
        Log.d(TAG, "üîç 6. Test envoi action...");
        Intent testIntent = new Intent(QuranAudioService.ACTION_NEXT);
        testIntent.setPackage(context.getPackageName());
        try {
            context.sendBroadcast(testIntent);
            Log.d(TAG, "üîç - Action test envoy√©e avec succ√®s");
            widgetDebugLog(TAG, "üîç Action test envoy√©e");
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Erreur envoi action test: " + e.getMessage());
            widgetDebugLog(TAG, "‚ùå Erreur action test: " + e.getMessage());
        }
        
        Log.d(TAG, "üîç DIAGNOSTIC COMPLET TERMIN√â");
        widgetDebugLog(TAG, "üîç Diagnostic termin√©");
    }
}
